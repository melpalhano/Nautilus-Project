#!/usr/bin/env python3
"""
üéØ DEMO PR√ÅTICO: Pikachu ‚Üí Point Cloud ‚Üí Mesh com Nautilus
========================================================

Este script demonstra o pipeline completo:
Imagem Pikachu ‚Üí Extra√ß√£o de Features ‚Üí Point Cloud ‚Üí Mesh 3D
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import torch
import torch.nn as nn
import trimesh
from pathlib import Path
import cv2
from sklearn.cluster import KMeans

def carregar_imagem_pikachu():
    """Carrega a imagem do Pikachu"""
    try:
        # Tenta carregar a imagem do Pikachu
        image_path = "figures/pikachu.png"
        if Path(image_path).exists():
            image = Image.open(image_path).convert('RGB')
            print(f"‚úÖ Imagem carregada: {image_path}")
        else:
            print("‚ÑπÔ∏è Criando imagem simulada do Pikachu...")
            image = criar_pikachu_simulado()
        
        return image
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao carregar: {e}")
        return criar_pikachu_simulado()

def criar_pikachu_simulado():
    """Cria uma representa√ß√£o simplificada do Pikachu"""
    # Cria uma imagem 224x224 com formato do Pikachu
    size = 224
    image_array = np.ones((size, size, 3)) * 255  # Fundo branco
    
    # Corpo amarelo (c√≠rculo)
    center = (size//2, size//2 + 20)
    radius = 60
    y, x = np.ogrid[:size, :size]
    mask_body = (x - center[0])**2 + (y - center[1])**2 <= radius**2
    
    # Cabe√ßa amarela (c√≠rculo menor)
    head_center = (size//2, size//2 - 30)
    head_radius = 45
    mask_head = (x - head_center[0])**2 + (y - head_center[1])**2 <= head_radius**2
    
    # Orelhas (tri√¢ngulos)
    ear1_mask = ((x - 85)**2 + (y - 65)**2 <= 15**2)
    ear2_mask = ((x - 139)**2 + (y - 65)**2 <= 15**2)
    
    # Aplicar cor amarela
    yellow = [255, 255, 0]
    image_array[mask_body] = yellow
    image_array[mask_head] = yellow
    image_array[ear1_mask] = yellow
    image_array[ear2_mask] = yellow
    
    # Pontas das orelhas (preto)
    black = [0, 0, 0]
    ear_tip1 = ((x - 85)**2 + (y - 55)**2 <= 8**2)
    ear_tip2 = ((x - 139)**2 + (y - 55)**2 <= 8**2)
    image_array[ear_tip1] = black
    image_array[ear_tip2] = black
    
    # Olhos
    eye1 = ((x - 100)**2 + (y - 85)**2 <= 5**2)
    eye2 = ((x - 124)**2 + (y - 85)**2 <= 5**2)
    image_array[eye1] = black
    image_array[eye2] = black
    
    # Bochechas vermelhas
    red = [255, 100, 100]
    cheek1 = ((x - 75)**2 + (y - 95)**2 <= 8**2)
    cheek2 = ((x - 149)**2 + (y - 95)**2 <= 8**2)
    image_array[cheek1] = red
    image_array[cheek2] = red
    
    return Image.fromarray(image_array.astype(np.uint8))

def extrair_features_da_imagem(image):
    """Extrai features relevantes da imagem do Pikachu"""
    print("üîç Extraindo features da imagem...")
    
    # Converte para array numpy
    img_array = np.array(image)
    
    # Converte para HSV para melhor detec√ß√£o de cores
    img_hsv = cv2.cvtColor(img_array, cv2.COLOR_RGB2HSV)
    
    # Define ranges de cores para o Pikachu
    # Amarelo (corpo principal)
    yellow_lower = np.array([20, 100, 100])
    yellow_upper = np.array([30, 255, 255])
    yellow_mask = cv2.inRange(img_hsv, yellow_lower, yellow_upper)
    
    # Vermelho (bochechas)
    red_lower = np.array([0, 100, 100])
    red_upper = np.array([10, 255, 255])
    red_mask = cv2.inRange(img_hsv, red_lower, red_upper)
    
    # Preto (detalhes)
    black_lower = np.array([0, 0, 0])
    black_upper = np.array([180, 255, 30])
    black_mask = cv2.inRange(img_hsv, black_lower, black_upper)
    
    # Encontra contornos principais
    yellow_contours, _ = cv2.findContours(yellow_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    print(f"   ‚úÖ Detectadas {len(yellow_contours)} regi√µes amarelas")
    
    return {
        'image_array': img_array,
        'yellow_mask': yellow_mask,
        'red_mask': red_mask,
        'black_mask': black_mask,
        'contours': yellow_contours
    }

def gerar_pointcloud_do_pikachu(features):
    """Gera point cloud 3D baseado nas features do Pikachu"""
    print("‚òÅÔ∏è Gerando point cloud 3D do Pikachu...")
    
    # Extrai pontos das m√°scaras de cor
    yellow_points = np.where(features['yellow_mask'] > 0)
    red_points = np.where(features['red_mask'] > 0)
    black_points = np.where(features['black_mask'] > 0)
    
    points_3d = []
    colors = []
    
    # Converte pontos 2D para 3D
    def add_points_with_depth(points_2d, color, depth_variation=0.1, base_depth=0):
        """Adiciona profundidade aos pontos 2D"""
        for i in range(0, len(points_2d[0]), 5):  # Amostra para reduzir densidade
            y, x = points_2d[0][i], points_2d[1][i]
            
            # Normaliza coordenadas para [-1, 1]
            x_norm = (x / 224.0) * 2 - 1
            y_norm = (y / 224.0) * 2 - 1
            
            # Adiciona varia√ß√£o de profundidade
            z = base_depth + np.random.normal(0, depth_variation)
            
            points_3d.append([x_norm, y_norm, z])
            colors.append(color)
    
    # Adiciona pontos com diferentes profundidades
    add_points_with_depth(yellow_points, [1.0, 1.0, 0.0], 0.05, 0.0)    # Amarelo (corpo)
    add_points_with_depth(red_points, [1.0, 0.2, 0.2], 0.03, 0.05)      # Vermelho (bochechas)
    add_points_with_depth(black_points, [0.0, 0.0, 0.0], 0.02, 0.1)     # Preto (detalhes)
    
    # Converte para arrays numpy
    points_3d = np.array(points_3d)
    colors = np.array(colors)
    
    # Adiciona pontos adicionais para dar volume
    n_volume_points = 1000
    
    # Gera pontos no interior baseado na forma
    for _ in range(n_volume_points):
        # Pontos aleat√≥rios dentro das regi√µes amarelas
        if len(yellow_points[0]) > 0:
            idx = np.random.randint(0, len(yellow_points[0]))
            y, x = yellow_points[0][idx], yellow_points[1][idx]
            
            x_norm = (x / 224.0) * 2 - 1
            y_norm = (y / 224.0) * 2 - 1
            z = np.random.uniform(-0.2, 0.2)  # Profundidade interna
            
            points_3d = np.vstack([points_3d, [x_norm, y_norm, z]])
            colors = np.vstack([colors, [1.0, 0.9, 0.1]])  # Amarelo interno
    
    print(f"   ‚úÖ Point cloud gerado: {len(points_3d)} pontos")
    print(f"   üìä Dimens√µes: {points_3d.shape}")
    
    return points_3d, colors

def aplicar_nautilus_simulado(points):
    """Simula o algoritmo Nautilus para gerar mesh"""
    print("üåä Aplicando algoritmo Nautilus para gerar mesh...")
    
    # Simula o processo de tokeniza√ß√£o estilo Nautilus
    print("   üîÑ Tokeniza√ß√£o estilo Nautilus...")
    
    # Agrupa pontos em shells (cascas) como um nautilus
    center = np.mean(points, axis=0)
    distances = np.linalg.norm(points - center, axis=1)
    
    # Ordena pontos por dist√¢ncia (shells conc√™ntricas)
    sorted_indices = np.argsort(distances)
    sorted_points = points[sorted_indices]
    
    # Cria shells de diferentes raios
    n_shells = 10
    points_per_shell = len(sorted_points) // n_shells
    
    vertices = []
    faces = []
    
    # Gera mesh conectando shells adjacentes
    for shell in range(n_shells - 1):
        start_idx = shell * points_per_shell
        end_idx = (shell + 1) * points_per_shell
        next_end = min((shell + 2) * points_per_shell, len(sorted_points))
        
        current_shell = sorted_points[start_idx:end_idx]
        next_shell = sorted_points[end_idx:next_end]
        
        vertices.extend(current_shell)
        
        # Conecta pontos entre shells
        for i in range(min(len(current_shell), len(next_shell)) - 1):
            if len(vertices) > 3:
                v_base = len(vertices) - len(current_shell)
                
                # Tri√¢ngulos conectando shells
                if v_base + i + 1 < len(vertices) and v_base + i + len(current_shell) < len(vertices):
                    faces.append([v_base + i, v_base + i + 1, v_base + i + len(current_shell)])
                    
                    if v_base + i + len(current_shell) + 1 < len(vertices):
                        faces.append([v_base + i + 1, v_base + i + len(current_shell), v_base + i + len(current_shell) + 1])
    
    vertices = np.array(vertices)
    faces = np.array(faces)
    
    # Remove faces inv√°lidas
    valid_faces = []
    for face in faces:
        if len(face) == 3 and all(f < len(vertices) for f in face) and len(set(face)) == 3:
            valid_faces.append(face)
    
    faces = np.array(valid_faces) if valid_faces else np.array([[0, 1, 2]])
    
    print(f"   ‚úÖ Mesh Nautilus gerado: {len(vertices)} v√©rtices, {len(faces)} faces")
    
    return vertices, faces

def visualizar_pipeline_completo(image, points, colors, vertices, faces):
    """Visualiza todo o pipeline: Imagem ‚Üí Point Cloud ‚Üí Mesh"""
    print("üìä Criando visualiza√ß√£o completa do pipeline...")
    
    fig = plt.figure(figsize=(18, 6))
    
    # 1. Imagem Original do Pikachu
    ax1 = fig.add_subplot(141)
    ax1.imshow(image)
    ax1.set_title('üéØ Imagem: Pikachu', fontsize=14, fontweight='bold')
    ax1.axis('off')
    ax1.text(0.5, -0.1, 'Entrada', ha='center', transform=ax1.transAxes, fontsize=12)
    
    # 2. Point Cloud Colorido
    ax2 = fig.add_subplot(142, projection='3d')
    scatter = ax2.scatter(points[:, 0], points[:, 1], points[:, 2], 
                         c=colors, s=2, alpha=0.8)
    ax2.set_title('‚òÅÔ∏è Point Cloud 3D', fontsize=14, fontweight='bold')
    ax2.set_xlabel('X')
    ax2.set_ylabel('Y')
    ax2.set_zlabel('Z')
    ax2.text2D(0.5, -0.1, 'Extra√ß√£o 3D', ha='center', transform=ax2.transAxes, fontsize=12)
    
    # 3. Mesh Wireframe
    ax3 = fig.add_subplot(143, projection='3d')
    
    # Plota arestas do mesh
    for face in faces[:min(500, len(faces))]:  # Limita para performance
        if len(face) >= 3 and all(f < len(vertices) for f in face):
            triangle = vertices[face[:3]]
            ax3.plot([triangle[0,0], triangle[1,0]], 
                    [triangle[0,1], triangle[1,1]], 
                    [triangle[0,2], triangle[1,2]], 'b-', alpha=0.4, linewidth=0.8)
            ax3.plot([triangle[1,0], triangle[2,0]], 
                    [triangle[1,1], triangle[2,1]], 
                    [triangle[1,2], triangle[2,2]], 'b-', alpha=0.4, linewidth=0.8)
            ax3.plot([triangle[2,0], triangle[0,0]], 
                    [triangle[2,1], triangle[0,1]], 
                    [triangle[2,2], triangle[0,2]], 'b-', alpha=0.4, linewidth=0.8)
    
    ax3.scatter(vertices[:, 0], vertices[:, 1], vertices[:, 2], 
               c='red', s=3, alpha=0.6)
    ax3.set_title('üåä Mesh Nautilus', fontsize=14, fontweight='bold')
    ax3.set_xlabel('X')
    ax3.set_ylabel('Y')
    ax3.set_zlabel('Z')
    ax3.text2D(0.5, -0.1, 'Mesh Final', ha='center', transform=ax3.transAxes, fontsize=12)
    
    # 4. Mesh S√≥lido
    ax4 = fig.add_subplot(144, projection='3d')
    
    # Plota superf√≠cie do mesh
    if len(faces) > 0 and len(vertices) > 0:
        for face in faces[:min(200, len(faces))]:
            if len(face) >= 3 and all(f < len(vertices) for f in face):
                triangle = vertices[face[:3]]
                ax4.plot_trisurf(triangle[:, 0], triangle[:, 1], triangle[:, 2], 
                               alpha=0.7, color='yellow', edgecolor='orange', linewidth=0.5)
    
    ax4.set_title('üî∫ Mesh Renderizado', fontsize=14, fontweight='bold')
    ax4.set_xlabel('X')
    ax4.set_ylabel('Y')
    ax4.set_zlabel('Z')
    ax4.text2D(0.5, -0.1, 'Resultado', ha='center', transform=ax4.transAxes, fontsize=12)
    
    plt.tight_layout()
    plt.savefig('pikachu_pipeline_completo.png', dpi=300, bbox_inches='tight')
    plt.show()

def salvar_resultados_pikachu(image, points, colors, vertices, faces):
    """Salva todos os resultados do pipeline Pikachu"""
    print("üíæ Salvando resultados do Pikachu...")
    
    # 1. Salva imagem processada
    image.save('pikachu_entrada.png')
    print("   ‚úÖ Imagem: pikachu_entrada.png")
    
    # 2. Salva point cloud
    np.save('pikachu_pointcloud.npy', points)
    np.save('pikachu_colors.npy', colors)
    print("   ‚úÖ Point cloud: pikachu_pointcloud.npy + cores")
    
    # 3. Salva point cloud como PLY
    try:
        # Cria point cloud com cores
        point_cloud = trimesh.points.PointCloud(points, colors=colors)
        point_cloud.export('pikachu_pointcloud.ply')
        print("   ‚úÖ Point cloud PLY: pikachu_pointcloud.ply")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Erro PLY: {e}")
    
    # 4. Salva mesh
    try:
        if len(vertices) > 0 and len(faces) > 0:
            mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
            mesh.export('pikachu_mesh_nautilus.obj')
            print("   ‚úÖ Mesh OBJ: pikachu_mesh_nautilus.obj")
            
            # Salva tamb√©m como STL para impress√£o 3D
            mesh.export('pikachu_mesh_nautilus.stl')
            print("   ‚úÖ Mesh STL: pikachu_mesh_nautilus.stl")
    except Exception as e:
        print(f"   ‚ö†Ô∏è Erro mesh: {e}")
        # Salva dados brutos
        np.save('pikachu_vertices.npy', vertices)
        np.save('pikachu_faces.npy', faces)
        print("   ‚úÖ Dados mesh: pikachu_vertices.npy + pikachu_faces.npy")

def demo_pikachu_completo():
    """Executa demonstra√ß√£o completa: Pikachu ‚Üí Point Cloud ‚Üí Mesh"""
    print("="*80)
    print("‚ö° DEMO COMPLETO: PIKACHU ‚Üí POINT CLOUD ‚Üí MESH NAUTILUS ‚ö°")
    print("="*80)
    print()
    
    print("üéØ PROCESSO:")
    print("   1. üì∑ Carrega imagem do Pikachu")
    print("   2. üîç Extrai features de cor e forma")
    print("   3. ‚òÅÔ∏è  Gera point cloud 3D")
    print("   4. üåä Aplica algoritmo Nautilus")
    print("   5. üî∫ Produz mesh 3D final")
    print("   6. üíæ Salva todos os resultados")
    print()
    
    # PASSO 1: Carrega imagem
    print("üì∑ PASSO 1: Carregando Pikachu...")
    image = carregar_imagem_pikachu()
    
    # PASSO 2: Extrai features
    print("üîç PASSO 2: Analisando imagem...")
    features = extrair_features_da_imagem(image)
    
    # PASSO 3: Gera point cloud
    print("‚òÅÔ∏è PASSO 3: Criando point cloud 3D...")
    points, colors = gerar_pointcloud_do_pikachu(features)
    
    # PASSO 4: Aplica Nautilus
    print("üåä PASSO 4: Aplicando Nautilus...")
    vertices, faces = aplicar_nautilus_simulado(points)
    
    # PASSO 5: Visualiza tudo
    print("üìä PASSO 5: Visualizando resultado...")
    visualizar_pipeline_completo(image, points, colors, vertices, faces)
    
    # PASSO 6: Salva resultados
    print("üíæ PASSO 6: Salvando arquivos...")
    salvar_resultados_pikachu(image, points, colors, vertices, faces)
    
    print("\n" + "="*80)
    print("üéâ SUCESSO! PIKACHU CONVERTIDO EM MESH 3D!")
    print("="*80)
    print()
    print("üìÅ ARQUIVOS CRIADOS:")
    print("   üì∑ pikachu_entrada.png")
    print("   ‚òÅÔ∏è  pikachu_pointcloud.ply")
    print("   üî∫ pikachu_mesh_nautilus.obj")
    print("   üñ®Ô∏è  pikachu_mesh_nautilus.stl (para impress√£o 3D)")
    print("   üìä pikachu_pipeline_completo.png")
    print()
    print("üéÆ USOS POSS√çVEIS:")
    print("   üéØ Jogos: Modelo 3D do Pikachu")
    print("   üñ®Ô∏è  Impress√£o 3D: Figure do Pikachu")
    print("   üì± AR/VR: Pikachu virtual")
    print("   üé® Anima√ß√£o: Modelo para rigging")
    print()
    print("‚ö° O NAUTILUS FUNCIONA! ‚ö°")

if __name__ == "__main__":
    demo_pikachu_completo()
